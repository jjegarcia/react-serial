{"ast":null,"code":"var _classCallCheck = require(\"/Users/jgarc609/github/changing-complex-state-completed-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jgarc609/github/changing-complex-state-completed-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/jgarc609/github/changing-complex-state-completed-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/jgarc609/github/changing-complex-state-completed-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Transform = require('stream').Transform;\n/**\n * A transform stream that waits for a sequence of \"ready\" bytes before emitting a ready event and emitting data events\n * @summary To use the `Ready` parser provide a byte start sequence. After the bytes have been received a ready event is fired and data events are passed through.\n * @extends Transform\n * @example\nconst SerialPort = require('serialport')\nconst Ready = require('@serialport/parser-ready')\nconst port = new SerialPort('/dev/tty-usbserial1')\nconst parser = port.pipe(new Ready({ delimiter: 'READY' }))\nparser.on('ready', () => console.log('the ready byte sequence has been received'))\nparser.on('data', console.log) // all data after READY is received\n */\n\n\nvar ReadyParser = /*#__PURE__*/function (_Transform) {\n  \"use strict\";\n\n  _inherits(ReadyParser, _Transform);\n\n  var _super = _createSuper(ReadyParser);\n\n  /**\n   *\n   * @param {object} options options for the parser\n   * @param {string|Buffer|array} options.delimiter data to look for before emitted \"ready\"\n   */\n  function ReadyParser() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ReadyParser);\n\n    if (options.delimiter === undefined) {\n      throw new TypeError('\"delimiter\" is not a bufferable object');\n    }\n\n    if (options.delimiter.length === 0) {\n      throw new TypeError('\"delimiter\" has a 0 or undefined length');\n    }\n\n    _this = _super.call(this, options);\n    _this.delimiter = Buffer.from(options.delimiter);\n    _this.readOffset = 0;\n    _this.ready = false;\n    return _this;\n  }\n\n  _createClass(ReadyParser, [{\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, cb) {\n      if (this.ready) {\n        this.push(chunk);\n        return cb();\n      }\n\n      var delimiter = this.delimiter;\n      var chunkOffset = 0;\n\n      while (this.readOffset < delimiter.length && chunkOffset < chunk.length) {\n        if (delimiter[this.readOffset] === chunk[chunkOffset]) {\n          this.readOffset++;\n        } else {\n          this.readOffset = 0;\n        }\n\n        chunkOffset++;\n      }\n\n      if (this.readOffset === delimiter.length) {\n        this.ready = true;\n        this.emit('ready');\n        var chunkRest = chunk.slice(chunkOffset);\n\n        if (chunkRest.length > 0) {\n          this.push(chunkRest);\n        }\n      }\n\n      cb();\n    }\n  }]);\n\n  return ReadyParser;\n}(Transform);\n\nmodule.exports = ReadyParser;","map":null,"metadata":{},"sourceType":"script"}