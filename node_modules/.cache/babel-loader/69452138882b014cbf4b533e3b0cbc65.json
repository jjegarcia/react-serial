{"ast":null,"code":"var _classCallCheck = require(\"/Users/jgarc609/github/changing-complex-state-completed-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jgarc609/github/changing-complex-state-completed-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/jgarc609/github/changing-complex-state-completed-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/jgarc609/github/changing-complex-state-completed-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/jgarc609/github/changing-complex-state-completed-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar debug = require('debug');\n\nvar logger = debug('serialport/bindings/poller');\n\nvar EventEmitter = require('events');\n\nvar FDPoller = require('bindings')('bindings.node').Poller;\n\nvar EVENTS = {\n  UV_READABLE: 1,\n  UV_WRITABLE: 2,\n  UV_DISCONNECT: 4\n};\n\nfunction handleEvent(error, eventFlag) {\n  if (error) {\n    logger('error', error);\n    this.emit('readable', error);\n    this.emit('writable', error);\n    this.emit('disconnect', error);\n    return;\n  }\n\n  if (eventFlag & EVENTS.UV_READABLE) {\n    logger('received \"readable\"');\n    this.emit('readable', null);\n  }\n\n  if (eventFlag & EVENTS.UV_WRITABLE) {\n    logger('received \"writable\"');\n    this.emit('writable', null);\n  }\n\n  if (eventFlag & EVENTS.UV_DISCONNECT) {\n    logger('received \"disconnect\"');\n    this.emit('disconnect', null);\n  }\n}\n/**\n * Polls unix systems for readable or writable states of a file or serialport\n */\n\n\nvar Poller = /*#__PURE__*/function (_EventEmitter) {\n  \"use strict\";\n\n  _inherits(Poller, _EventEmitter);\n\n  var _super = _createSuper(Poller);\n\n  function Poller(fd) {\n    var _this;\n\n    _classCallCheck(this, Poller);\n\n    logger('Creating poller');\n    _this = _super.call(this);\n    _this.poller = new FDPoller(fd, handleEvent.bind(_assertThisInitialized(_this)));\n    return _this;\n  }\n  /**\n   * Wait for the next event to occur\n   * @param {string} event ('readable'|'writable'|'disconnect')\n   * @returns {Poller} returns itself\n   */\n\n\n  _createClass(Poller, [{\n    key: \"once\",\n    value: function once(event) {\n      switch (event) {\n        case 'readable':\n          this.poll(EVENTS.UV_READABLE);\n          break;\n\n        case 'writable':\n          this.poll(EVENTS.UV_WRITABLE);\n          break;\n\n        case 'disconnect':\n          this.poll(EVENTS.UV_DISCONNECT);\n          break;\n      }\n\n      return EventEmitter.prototype.once.apply(this, arguments);\n    }\n    /**\n     * Ask the bindings to listen for an event, it is recommend to use `.once()` for easy use\n     * @param {EVENTS} eventFlag polls for an event or group of events based upon a flag.\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"poll\",\n    value: function poll(eventFlag) {\n      eventFlag = eventFlag || 0;\n\n      if (eventFlag & EVENTS.UV_READABLE) {\n        logger('Polling for \"readable\"');\n      }\n\n      if (eventFlag & EVENTS.UV_WRITABLE) {\n        logger('Polling for \"writable\"');\n      }\n\n      if (eventFlag & EVENTS.UV_DISCONNECT) {\n        logger('Polling for \"disconnect\"');\n      }\n\n      this.poller.poll(eventFlag);\n    }\n    /**\n     * Stop listening for events and cancel all outstanding listening with an error\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      logger('Stopping poller');\n      this.poller.stop();\n      this.emitCanceled();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      logger('Destroying poller');\n      this.poller.destroy();\n      this.emitCanceled();\n    }\n  }, {\n    key: \"emitCanceled\",\n    value: function emitCanceled() {\n      var err = new Error('Canceled');\n      err.canceled = true;\n      this.emit('readable', err);\n      this.emit('writable', err);\n      this.emit('disconnect', err);\n    }\n  }]);\n\n  return Poller;\n}(EventEmitter);\n\nPoller.EVENTS = EVENTS;\nmodule.exports = Poller;","map":null,"metadata":{},"sourceType":"script"}