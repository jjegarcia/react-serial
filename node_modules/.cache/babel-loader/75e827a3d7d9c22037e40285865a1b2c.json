{"ast":null,"code":"var _classCallCheck = require(\"/Users/jgarc609/github/changing-complex-state-completed-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jgarc609/github/changing-complex-state-completed-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar debug = require('debug')('serialport/binding-abstract');\n/**\n * @name Binding\n * @type {AbstractBinding}\n * @since 5.0.0\n * @description The `Binding` is how Node-SerialPort talks to the underlying system. By default, we auto detect Windows, Linux and OS X, and load the appropriate module for your system. You can assign `SerialPort.Binding` to any binding you like. Find more by searching at [npm](https://npmjs.org/).\n  Prevent auto loading the default bindings by requiring SerialPort with:\n  ```js\n  var SerialPort = require('@serialport/stream');\n  SerialPort.Binding = MyBindingClass;\n  ```\n */\n\n/**\n * You never have to use `Binding` objects directly. SerialPort uses them to access the underlying hardware. This documentation is geared towards people who are making bindings for different platforms. This class can be inherited from to get type checking for each method.\n * @class AbstractBinding\n * @param {object} options options for the binding\n * @property {boolean} isOpen Required property. `true` if the port is open, `false` otherwise. Should be read-only.\n * @throws {TypeError} When given invalid arguments, a `TypeError` is thrown.\n * @since 5.0.0\n */\n\n\nvar AbstractBinding = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function AbstractBinding(opt) {\n    _classCallCheck(this, AbstractBinding);\n\n    if (typeof opt !== 'object') {\n      throw new TypeError('\"options\" is not an object');\n    }\n  }\n  /**\n   * Opens a connection to the serial port referenced by the path.\n   * @param {string} path the path or com port to open\n   * @param {openOptions} options openOptions for the serialport\n   * @returns {Promise} Resolves after the port is opened and configured.\n   * @throws {TypeError} When given invalid arguments, a `TypeError` is thrown.\n   */\n\n\n  _createClass(AbstractBinding, [{\n    key: \"open\",\n    value: function open(path, options) {\n      if (!path) {\n        throw new TypeError('\"path\" is not a valid port');\n      }\n\n      if (typeof options !== 'object') {\n        throw new TypeError('\"options\" is not an object');\n      }\n\n      debug('open');\n\n      if (this.isOpen) {\n        return Promise.reject(new Error('Already open'));\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Closes an open connection\n     * @returns {Promise} Resolves once the connection is closed.\n     * @throws {TypeError} When given invalid arguments, a `TypeError` is thrown.\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      debug('close');\n\n      if (!this.isOpen) {\n        return Promise.reject(new Error('Port is not open'));\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Request a number of bytes from the SerialPort. This function is similar to Node's [`fs.read`](http://nodejs.org/api/fs.html#fs_fs_read_fd_buffer_offset_length_position_callback) except it will always return at least one byte.\n    The in progress reads must error when the port is closed with an error object that has the property `canceled` equal to `true`. Any other error will cause a disconnection.\n      * @param {buffer} buffer Accepts a [`Buffer`](http://nodejs.org/api/buffer.html) object.\n     * @param {integer} offset The offset in the buffer to start writing at.\n     * @param {integer} length Specifies the maximum number of bytes to read.\n     * @returns {Promise} Resolves with the number of bytes read after a read operation.\n     * @throws {TypeError} When given invalid arguments, a `TypeError` is thrown.\n     */\n\n  }, {\n    key: \"read\",\n    value: function read(buffer, offset, length) {\n      if (!Buffer.isBuffer(buffer)) {\n        throw new TypeError('\"buffer\" is not a Buffer');\n      }\n\n      if (typeof offset !== 'number') {\n        throw new TypeError('\"offset\" is not an integer');\n      }\n\n      if (typeof length !== 'number') {\n        throw new TypeError('\"length\" is not an integer');\n      }\n\n      debug('read');\n\n      if (buffer.length < offset + length) {\n        return Promise.reject(new Error('buffer is too small'));\n      }\n\n      if (!this.isOpen) {\n        return Promise.reject(new Error('Port is not open'));\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Write bytes to the SerialPort. Only called when there is no pending write operation.\n    The in progress writes must error when the port is closed with an error object that has the property `canceled` equal to `true`. Any other error will cause a disconnection.\n      * @param {buffer} buffer - Accepts a [`Buffer`](http://nodejs.org/api/buffer.html) object.\n     * @returns {Promise} Resolves after the data is passed to the operating system for writing.\n     * @throws {TypeError} When given invalid arguments, a `TypeError` is thrown.\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(buffer) {\n      if (!Buffer.isBuffer(buffer)) {\n        throw new TypeError('\"buffer\" is not a Buffer');\n      }\n\n      debug('write', buffer.length, 'bytes');\n\n      if (!this.isOpen) {\n        return Promise.reject(new Error('Port is not open'));\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Changes connection settings on an open port. Only `baudRate` is supported.\n     * @param {object=} options Only supports `baudRate`.\n     * @param {number=} [options.baudRate] If provided a baud rate that the bindings do not support, it should reject.\n     * @returns {Promise} Resolves once the port's baud rate changes.\n     * @throws {TypeError} When given invalid arguments, a `TypeError` is thrown.\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(options) {\n      if (typeof options !== 'object') {\n        throw TypeError('\"options\" is not an object');\n      }\n\n      if (typeof options.baudRate !== 'number') {\n        throw new TypeError('\"options.baudRate\" is not a number');\n      }\n\n      debug('update');\n\n      if (!this.isOpen) {\n        return Promise.reject(new Error('Port is not open'));\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Set control flags on an open port.\n     * @param {object=} options All options are operating system default when the port is opened. Every flag is set on each call to the provided or default values. All options are always provided.\n     * @param {Boolean} [options.brk=false] flag for brk\n     * @param {Boolean} [options.cts=false] flag for cts\n     * @param {Boolean} [options.dsr=false] flag for dsr\n     * @param {Boolean} [options.dtr=true] flag for dtr\n     * @param {Boolean} [options.rts=true] flag for rts\n     * @returns {Promise} Resolves once the port's flags are set.\n     * @throws {TypeError} When given invalid arguments, a `TypeError` is thrown.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('\"options\" is not an object');\n      }\n\n      debug('set');\n\n      if (!this.isOpen) {\n        return Promise.reject(new Error('Port is not open'));\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Get the control flags (CTS, DSR, DCD) on the open port.\n     * @returns {Promise} Resolves with the retrieved flags.\n     * @throws {TypeError} When given invalid arguments, a `TypeError` is thrown.\n     */\n\n  }, {\n    key: \"get\",\n    value: function get() {\n      debug('get');\n\n      if (!this.isOpen) {\n        return Promise.reject(new Error('Port is not open'));\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Get the OS reported baud rate for the open port.\n     * Used mostly for debugging custom baud rates.\n     * @returns {Promise} Resolves with the current baud rate.\n     * @throws {TypeError} When given invalid arguments, a `TypeError` is thrown.\n     */\n\n  }, {\n    key: \"getBaudRate\",\n    value: function getBaudRate() {\n      debug('getbaudRate');\n\n      if (!this.isOpen) {\n        return Promise.reject(new Error('Port is not open'));\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Flush (discard) data received but not read, and written but not transmitted.\n     * @returns {Promise} Resolves once the flush operation finishes.\n     * @throws {TypeError} When given invalid arguments, a `TypeError` is thrown.\n     */\n\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      debug('flush');\n\n      if (!this.isOpen) {\n        return Promise.reject(new Error('Port is not open'));\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Drain waits until all output data is transmitted to the serial port. An in progress write should be completed before this returns.\n     * @returns {Promise} Resolves once the drain operation finishes.\n     * @throws {TypeError} When given invalid arguments, a `TypeError` is thrown.\n     */\n\n  }, {\n    key: \"drain\",\n    value: function drain() {\n      debug('drain');\n\n      if (!this.isOpen) {\n        return Promise.reject(new Error('Port is not open'));\n      }\n\n      return Promise.resolve();\n    }\n  }], [{\n    key: \"list\",\n    value:\n    /**\n     * Retrieves a list of available serial ports with metadata. The `comName` must be guaranteed, and all other fields should be undefined if unavailable. The `comName` is either the path or an identifier (eg `COM1`) used to open the serialport.\n     * @returns {Promise} resolves to an array of port [info objects](#module_serialport--SerialPort.list).\n     */\n    function list() {\n      debug('list');\n      return Promise.resolve();\n    }\n  }]);\n\n  return AbstractBinding;\n}();\n\nmodule.exports = AbstractBinding;","map":null,"metadata":{},"sourceType":"script"}